<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" id="dark-theme">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" id="light-theme">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #ffffff; --bg-secondary: #f8f9fa; --text-primary: #333333;
            --text-secondary: #666666; --border-color: #e1e5e9; --accent-color: #6366f1;
            --code-bg: #f8f9fa; --sidebar-bg: #ffffff; --shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        [data-theme="dark"] {
            --bg-primary: #0d1117; --bg-secondary: #161b22; --text-primary: #e6edf3;
            --text-secondary: #7d8590; --border-color: #30363d; --accent-color: #58a6ff;
            --code-bg: #161b22; --sidebar-bg: #0d1117; --shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            line-height: 1.6; 
            background-color: var(--bg-primary); 
            color: var(--text-primary); 
            transition: all 0.3s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .container { 
            display: flex; 
            min-height: 100vh;
            width: 100%;
            max-width: 100vw;
            overflow-x: hidden;
        }
        
        .sidebar { 
            width: 280px; 
            background-color: var(--sidebar-bg); 
            border-right: 1px solid var(--border-color); 
            position: fixed; 
            height: 100vh; 
            overflow-y: auto; 
            box-shadow: var(--shadow); 
            transition: transform 0.3s ease; 
            z-index: 200;
        }
        
        .main-content { 
            flex: 1; 
            margin-left: 280px; 
            transition: margin-left 0.3s ease;
            width: calc(100% - 280px);
            max-width: calc(100vw - 280px);
            overflow-x: hidden;
        }
        
        .header { 
            background-color: var(--sidebar-bg); 
            border-bottom: 1px solid var(--border-color); 
            padding: 1rem 2rem; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            position: sticky; 
            top: 0; 
            z-index: 100; 
            box-shadow: var(--shadow);
        }
        
        .theme-toggle { 
            background: none; 
            border: 2px solid var(--border-color); 
            padding: 0.5rem 1rem; 
            border-radius: 6px; 
            cursor: pointer; 
            color: var(--text-primary); 
            font-size: 0.9rem; 
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .theme-toggle:hover { background-color: var(--bg-secondary); }
        
        .mobile-menu-btn { 
            display: none; 
            background: none; 
            border: 2px solid var(--border-color); 
            padding: 0.5rem; 
            border-radius: 6px; 
            cursor: pointer; 
            color: var(--text-primary); 
            font-size: 1.2rem; 
            transition: all 0.2s ease;
        }
        .mobile-menu-btn:hover { background-color: var(--bg-secondary); }
        
        .mobile-overlay { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.5); 
            z-index: 150; 
            opacity: 0; 
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .mobile-overlay.active { 
            opacity: 1; 
            pointer-events: auto;
        }
        
        .content { 
            padding: 2rem; 
            max-width: 1200px; 
            margin: 0 auto;
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        h1 { 
            font-size: clamp(1.8rem, 4vw, 2.5rem); 
            margin-bottom: 1rem; 
            color: var(--text-primary); 
            border-bottom: 3px solid var(--accent-color); 
            padding-bottom: 0.5rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        h2 { 
            font-size: clamp(1.4rem, 3vw, 2rem); 
            margin: 2rem 0 1rem 0; 
            color: var(--text-primary); 
            border-bottom: 2px solid var(--border-color); 
            padding-bottom: 0.5rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .h2-link{
            font-weight:700;
        }
        
        h3 { 
            font-size: clamp(1.2rem, 2.5vw, 1.5rem); 
            margin: 1.5rem 0 1rem 0; 
            color: var(--accent-color);
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        p { 
            margin-bottom: 1rem; 
            color: var(--text-secondary);
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            max-width: 100%;
        }
        
        .code-container { 
            position: relative; 
            margin: 1.5rem 0; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: var(--shadow);
            max-width: 100%;
        }
        
        .code-header { 
            background-color: var(--bg-secondary); 
            padding: 0.75rem 1rem; 
            border-bottom: 1px solid var(--border-color); 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .copy-btn { 
            background: var(--accent-color); 
            color: white; 
            border: none; 
            padding: 0.4rem 0.8rem; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 0.8rem;
            white-space: nowrap;
            transition: all 0.2s ease;
        }
        .copy-btn:hover { opacity: 0.9; }
        
        pre[class*="language-"] { 
            margin: 0 !important; 
            padding: 1rem !important;
            background: var(--code-bg) !important;
            border: none !important;
            border-radius: 0 !important;
            font-size: clamp(0.75rem, 2vw, 0.9rem) !important;
            line-height: 1.5 !important;
            overflow-x: auto !important;
            overflow-y: hidden !important;
            white-space: pre !important;
            word-wrap: normal !important;
            max-width: 100% !important;
            -webkit-overflow-scrolling: touch !important;
            scrollbar-width: thin !important;
            scrollbar-color: var(--accent-color) transparent !important;
        }
        
        pre[class*="language-"]::-webkit-scrollbar {
            height: 12px !important;
        }
        
        pre[class*="language-"]::-webkit-scrollbar-track {
            background: var(--bg-secondary) !important;
            border-radius: 6px !important;
        }
        
        pre[class*="language-"]::-webkit-scrollbar-thumb {
            background: var(--accent-color) !important;
            border-radius: 6px !important;
        }
        
        pre[class*="language-"]::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary) !important;
        }
        
        code[class*="language-"] { 
            background: transparent !important;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace !important;
            font-size: inherit !important;
            color: inherit !important;
            white-space: pre !important;
            word-wrap: normal !important;
            display: inline-block !important;
            min-width: max-content !important;
            width: auto !important;
        }
        
        [data-theme="dark"] .token.comment, [data-theme="dark"] .token.prolog, [data-theme="dark"] .token.doctype, [data-theme="dark"] .token.cdata { color: #7d8590 !important; font-style: italic !important; }
        [data-theme="dark"] .token.punctuation { color: #e6edf3 !important; }
        [data-theme="dark"] .token.property, [data-theme="dark"] .token.tag, [data-theme="dark"] .token.boolean, [data-theme="dark"] .token.number, [data-theme="dark"] .token.constant, .token.symbol, .token.deleted { color: #ff7b72 !important; }
        [data-theme="dark"] .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { color: #a5d6ff !important; }
        [data-theme="dark"] .token.operator, [data-theme="dark"] .token.entity, [data-theme="dark"] .token.url, .language-css .token.string, .style .token.string { color: #79c0ff !important; }
        [data-theme="dark"] .token.atrule, [data-theme="dark"] .token.attr-value, [data-theme="dark"] .token.keyword { color: #ff7b72 !important; }
        [data-theme="dark"] .token.function, [data-theme="dark"] .token.class-name { color: #d2a8ff !important; }
        [data-theme="dark"] .token.regex, [data-theme="dark"] .token.important, [data-theme="dark"] .token.variable { color: #ffa657 !important; }
        
        [data-theme="light"] .token.comment, [data-theme="light"] .token.prolog, [data-theme="light"] .token.doctype, [data-theme="light"] .token.cdata { color: #6a737d !important; }
        [data-theme="light"] .token.punctuation { color: #24292e !important; }
        [data-theme="light"] .token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted { color: #d73a49 !important; }
        [data-theme="light"] .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { color: #032f62 !important; }
        [data-theme="light"] .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { color: #24292e !important; }
        [data-theme="light"] .token.atrule, .token.attr-value, .token.keyword { color: #d73a49 !important; }
        [data-theme="light"] .token.function, .token.class-name { color: #6f42c1 !important; }
        [data-theme="light"] .token.regex, [data-theme="light"] .token.important, [data-theme="light"] .token.variable { color: #e36209 !important; }
        
        .toc { padding: 1rem; }
        .toc ul { list-style: none; }
        .toc li { margin: 0.5rem 0; }
        .toc a { 
            color: var(--text-secondary); 
            text-decoration: none; 
            display: block; 
            padding: 0.5rem; 
            border-radius: 6px; 
            transition: all 0.2s ease; 
            font-size: 0.9rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .toc a.active {
            color: blue !important;
             background-color: #5ec7ff2a;
}


        .toc a:hover { background-color: #0077ff16}
        
        @media (max-width: 767px) { 
            .sidebar { 
                transform: translateX(-100%);
                width: 85vw;
                max-width: 320px;
            }
            .sidebar.mobile-open { transform: translateX(0); }
            .main-content { 
                margin-left: 0;
                width: 100%;
                max-width: 100vw;
                overflow-x: auto;
            }
            .mobile-menu-btn { display: block; }
            .mobile-overlay { display: block; }
            .header { 
                padding: 0.75rem 1rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .content { 
                padding: 1rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .theme-toggle {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
            }
            .code-header {
                padding: 0.5rem;
                font-size: 0.8rem;
            }
            .copy-btn {
                padding: 0.3rem 0.6rem;
                font-size: 0.7rem;
            }
            pre[class*="language-"] {
                padding: 0.75rem !important;
                font-size: 0.75rem !important;
            }
            pre[class*="language-"]::-webkit-scrollbar {
                height: 10px !important;
            }
            .toc {
                padding: 0.75rem;
            }
            .toc a {
                font-size: 0.8rem;
                padding: 0.4rem;
            }
        }
        
        @media (max-width: 480px) {
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.3rem; }
            h3 { font-size: 1.1rem; }
            .content { padding: 0.75rem; }
            .header { padding: 0.5rem; }
            .sidebar { width: 90vw; }
            pre[class*="language-"] {
                font-size: 0.7rem !important;
                padding: 0.5rem !important;
            }
        }
    </style>
</head>
<body data-theme="light">
    <div class="mobile-overlay" id="mobile-overlay"></div>
    
    <div class="container">
        <nav class="sidebar" id="sidebar">
            <div class="toc">
                <h3 style="padding: 0.5rem; color: var(--text-primary);">Table of Contents</h3>
                <ul id="toc-list"></ul>
            </div>
        </nav>
        <main class="main-content">
            <header class="header">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <button class="mobile-menu-btn" id="mobile-menu-btn">â˜°</button>
                    <h2 style="margin: 0; color: var(--text-primary);">Documentation</h2>
                </div>
                <button class="theme-toggle" id="theme-toggle">ðŸŒ™ Dark Mode</button>
            </header>
            <div class="content" id="content">
<h2 id="-promises-async-await-25-questions-">**Promises & Async/Await (25 Questions)**</h2>

<p><strong>191. What is a Promise? What are its three states?</strong></p>

<p>A Promise is an object representing the eventual completion or failure of an asynchronous operation. It's a way to handle asynchronous operations more elegantly than callbacks.</p>

<p><strong>Three states:</strong></p>

<p>- <strong>Pending</strong>: Initial state, neither fulfilled nor rejected</p>
<p>- <strong>Fulfilled (Resolved)</strong>: Operation completed successfully</p>
<p>- <strong>Rejected</strong>: Operation failed</p>


<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20promise%20%3D%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%2F%2F%20Initially%20pending%0A%20%20setTimeout(()%20%3D%3E%20%7B%0A%20%20%20%20resolve(%22Success!%22)%3B%20%2F%2F%20Now%20fulfilled%0A%20%20%7D%2C%201000)%3B%0A%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {
  // Initially pending
  setTimeout(() =&gt; {
    resolve("Success!"); // Now fulfilled
  }, 1000);
});
</code></pre>
</div>

<p><strong>192. How do you create a Promise?</strong></p>

<p>You create a Promise using the Promise constructor that takes an executor function with resolve and reject parameters.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20myPromise%20%3D%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20const%20success%20%3D%20Math.random()%20%3E%200.5%3B%0A%20%20if%20(success)%20%7B%0A%20%20%20%20resolve(%22Operation%20successful%22)%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20reject(new%20Error(%22Operation%20failed%22))%3B%0A%20%20%7D%0A%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const myPromise = new Promise((resolve, reject) =&gt; {
  const success = Math.random() &gt; 0.5;
  if (success) {
    resolve("Operation successful");
  } else {
    reject(new Error("Operation failed"));
  }
});
</code></pre>
</div>

<p><strong>193. How do you consume a Promise using `.then()`, `.catch()`, and `.finally()`?</strong></p>

<p>- `.then()`: Handles successful resolution</p>
<p>- `.catch()`: Handles rejection/errors</p>
<p>- `.finally()`: Executes regardless of outcome</p>


<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="myPromise%0A%20%20.then(result%20%3D%3E%20console.log(%22Success%3A%22%2C%20result))%0A%20%20.catch(error%20%3D%3E%20console.log(%22Error%3A%22%2C%20error.message))%0A%20%20.finally(()%20%3D%3E%20console.log(%22Cleanup%20operations%22))%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">myPromise
  .then(result =&gt; console.log("Success:", result))
  .catch(error =&gt; console.log("Error:", error.message))
  .finally(() =&gt; console.log("Cleanup operations"));
</code></pre>
</div>

<p><strong>194. What is Promise chaining?</strong></p>

<p>Promise chaining allows you to execute multiple asynchronous operations in sequence, where each operation starts when the previous one completes.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="fetchUser(id)%0A%20%20.then(user%20%3D%3E%20fetchUserPosts(user.id))%0A%20%20.then(posts%20%3D%3E%20fetchPostComments(posts%5B0%5D.id))%0A%20%20.then(comments%20%3D%3E%20console.log(comments))%0A%20%20.catch(error%20%3D%3E%20console.error(error))%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">fetchUser(id)
  .then(user =&gt; fetchUserPosts(user.id))
  .then(posts =&gt; fetchPostComments(posts[0].id))
  .then(comments =&gt; console.log(comments))
  .catch(error =&gt; console.error(error));
</code></pre>
</div>

<p><strong>195. What is `Promise.all()` and when would you use it?</strong></p>

<p>`Promise.all()` runs multiple promises concurrently and resolves when all promises resolve, or rejects if any promise rejects.</p>

<p><strong>Use cases:</strong> When you need all operations to complete before proceeding.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20promises%20%3D%20%5B%0A%20%20fetch('%2Fapi%2Fusers')%2C%0A%20%20fetch('%2Fapi%2Fposts')%2C%0A%20%20fetch('%2Fapi%2Fcomments')%0A%5D%3B%0A%0APromise.all(promises)%0A%20%20.then(responses%20%3D%3E%20%7B%0A%20%20%20%20%2F%2F%20All%20requests%20completed%0A%20%20%20%20console.log(%22All%20data%20loaded%22)%3B%0A%20%20%7D)%0A%20%20.catch(error%20%3D%3E%20%7B%0A%20%20%20%20%2F%2F%20Any%20request%20failed%0A%20%20%20%20console.error(%22One%20or%20more%20requests%20failed%22)%3B%0A%20%20%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const promises = [
  fetch('/api/users'),
  fetch('/api/posts'),
  fetch('/api/comments')
];

Promise.all(promises)
  .then(responses =&gt; {
    // All requests completed
    console.log("All data loaded");
  })
  .catch(error =&gt; {
    // Any request failed
    console.error("One or more requests failed");
  });
</code></pre>
</div>

<p><strong>196. What is `Promise.allSettled()` and how is it different from `Promise.all()`?</strong></p>

<p>`Promise.allSettled()` waits for all promises to settle (resolve or reject) and returns results for all, regardless of individual outcomes.</p>

<p><strong>Difference:</strong> `Promise.all()` fails fast (rejects on first rejection), while `Promise.allSettled()` waits for all to complete.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="Promise.allSettled(%5B%0A%20%20Promise.resolve(%22Success%22)%2C%0A%20%20Promise.reject(%22Error%22)%2C%0A%20%20Promise.resolve(%22Another%20success%22)%0A%5D).then(results%20%3D%3E%20%7B%0A%20%20%2F%2F%20Results%3A%20%5B%0A%20%20%2F%2F%20%20%20%7B%20status%3A%20'fulfilled'%2C%20value%3A%20'Success'%20%7D%2C%0A%20%20%2F%2F%20%20%20%7B%20status%3A%20'rejected'%2C%20reason%3A%20'Error'%20%7D%2C%0A%20%20%2F%2F%20%20%20%7B%20status%3A%20'fulfilled'%2C%20value%3A%20'Another%20success'%20%7D%0A%20%20%2F%2F%20%5D%0A%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">Promise.allSettled([
  Promise.resolve("Success"),
  Promise.reject("Error"),
  Promise.resolve("Another success")
]).then(results =&gt; {
  // Results: [
  //   { status: 'fulfilled', value: 'Success' },
  //   { status: 'rejected', reason: 'Error' },
  //   { status: 'fulfilled', value: 'Another success' }
  // ]
});
</code></pre>
</div>

<p><strong>197. What is `Promise.race()` and when would you use it?</strong></p>

<p>`Promise.race()` resolves or rejects as soon as the first promise settles.</p>

<p><strong>Use cases:</strong> Timeouts, fastest response wins, cancellation patterns.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20timeout%20%3D%20new%20Promise((_%2C%20reject)%20%3D%3E%20%0A%20%20setTimeout(()%20%3D%3E%20reject(new%20Error(%22Timeout%22))%2C%205000)%0A)%3B%0A%0Aconst%20apiCall%20%3D%20fetch('%2Fapi%2Fdata')%3B%0A%0APromise.race(%5BapiCall%2C%20timeout%5D)%0A%20%20.then(response%20%3D%3E%20console.log(%22Got%20response%20before%20timeout%22))%0A%20%20.catch(error%20%3D%3E%20console.log(%22Request%20timed%20out%20or%20failed%22))%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const timeout = new Promise((_, reject) =&gt; 
  setTimeout(() =&gt; reject(new Error("Timeout")), 5000)
);

const apiCall = fetch('/api/data');

Promise.race([apiCall, timeout])
  .then(response =&gt; console.log("Got response before timeout"))
  .catch(error =&gt; console.log("Request timed out or failed"));
</code></pre>
</div>

<p><strong>198. What is `Promise.any()` and how does it work?</strong></p>

<p>`Promise.any()` resolves with the first fulfilled promise, ignoring rejections unless all promises reject.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="Promise.any(%5B%0A%20%20Promise.reject(%22Error%201%22)%2C%0A%20%20Promise.resolve(%22Success%22)%2C%0A%20%20Promise.reject(%22Error%202%22)%0A%5D).then(result%20%3D%3E%20%7B%0A%20%20console.log(result)%3B%20%2F%2F%20%22Success%22%0A%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">Promise.any([
  Promise.reject("Error 1"),
  Promise.resolve("Success"),
  Promise.reject("Error 2")
]).then(result =&gt; {
  console.log(result); // "Success"
});
</code></pre>
</div>

<p><strong>199. What is async/await and how does it work?</strong></p>

<p>`async/await` is syntactic sugar over Promises that makes asynchronous code look and behave more like synchronous code.</p>

<p>- `async` function always returns a Promise</p>
<p>- `await` pauses execution until Promise resolves</p>


<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20fetchUserData(id)%20%7B%0A%20%20try%20%7B%0A%20%20%20%20const%20user%20%3D%20await%20fetchUser(id)%3B%0A%20%20%20%20const%20posts%20%3D%20await%20fetchUserPosts(user.id)%3B%0A%20%20%20%20return%20%7B%20user%2C%20posts%20%7D%3B%0A%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20console.error(%22Error%20fetching%20data%3A%22%2C%20error)%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function fetchUserData(id) {
  try {
    const user = await fetchUser(id);
    const posts = await fetchUserPosts(user.id);
    return { user, posts };
  } catch (error) {
    console.error("Error fetching data:", error);
  }
}
</code></pre>
</div>

<p><strong>200. How do you handle errors in async/await?</strong></p>

<p>Use try-catch blocks to handle errors in async/await.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20handleAsyncOperation()%20%7B%0A%20%20try%20%7B%0A%20%20%20%20const%20result%20%3D%20await%20riskyOperation()%3B%0A%20%20%20%20return%20result%3B%0A%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20console.error(%22Operation%20failed%3A%22%2C%20error)%3B%0A%20%20%20%20throw%20error%3B%20%2F%2F%20Re-throw%20if%20needed%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function handleAsyncOperation() {
  try {
    const result = await riskyOperation();
    return result;
  } catch (error) {
    console.error("Operation failed:", error);
    throw error; // Re-throw if needed
  }
}
</code></pre>
</div>

<p><strong>201. Can you use await at the top level? How?</strong></p>

<p>Yes, in modern JavaScript (ES2022+) you can use top-level await in modules.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20In%20a%20module%20file%0Aconst%20data%20%3D%20await%20fetch('%2Fapi%2Fdata')%3B%0Aconst%20config%20%3D%20await%20import('.%2Fconfig.js')%3B%0A%0A%2F%2F%20Or%20wrap%20in%20async%20IIFE%20for%20older%20environments%0A(async%20()%20%3D%3E%20%7B%0A%20%20const%20result%20%3D%20await%20someAsyncOperation()%3B%0A%7D)()%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// In a module file
const data = await fetch('/api/data');
const config = await import('./config.js');

// Or wrap in async IIFE for older environments
(async () =&gt; {
  const result = await someAsyncOperation();
})();
</code></pre>
</div>

<p><strong>202. How would you run async operations in parallel using async/await?</strong></p>

<p>Start all operations before awaiting them, or use `Promise.all()`.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20parallelOperations()%20%7B%0A%20%20%2F%2F%20Start%20all%20operations%0A%20%20const%20promise1%20%3D%20fetchUser(1)%3B%0A%20%20const%20promise2%20%3D%20fetchUser(2)%3B%0A%20%20const%20promise3%20%3D%20fetchUser(3)%3B%0A%20%20%0A%20%20%2F%2F%20Wait%20for%20all%20to%20complete%0A%20%20const%20%5Buser1%2C%20user2%2C%20user3%5D%20%3D%20await%20Promise.all(%5B%0A%20%20%20%20promise1%2C%20promise2%2C%20promise3%0A%20%20%5D)%3B%0A%20%20%0A%20%20return%20%7B%20user1%2C%20user2%2C%20user3%20%7D%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function parallelOperations() {
  // Start all operations
  const promise1 = fetchUser(1);
  const promise2 = fetchUser(2);
  const promise3 = fetchUser(3);
  
  // Wait for all to complete
  const [user1, user2, user3] = await Promise.all([
    promise1, promise2, promise3
  ]);
  
  return { user1, user2, user3 };
}
</code></pre>
</div>

<p><strong>203. How would you run async operations sequentially?</strong></p>

<p>Await each operation before starting the next.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20sequentialOperations()%20%7B%0A%20%20const%20user1%20%3D%20await%20fetchUser(1)%3B%0A%20%20const%20user2%20%3D%20await%20fetchUser(2)%3B%0A%20%20const%20user3%20%3D%20await%20fetchUser(3)%3B%0A%20%20%0A%20%20return%20%5Buser1%2C%20user2%2C%20user3%5D%3B%0A%7D%0A%0A%2F%2F%20Or%20using%20for%20loop%0Aasync%20function%20processUsersSequentially(userIds)%20%7B%0A%20%20const%20results%20%3D%20%5B%5D%3B%0A%20%20for%20(const%20id%20of%20userIds)%20%7B%0A%20%20%20%20const%20user%20%3D%20await%20fetchUser(id)%3B%0A%20%20%20%20results.push(user)%3B%0A%20%20%7D%0A%20%20return%20results%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function sequentialOperations() {
  const user1 = await fetchUser(1);
  const user2 = await fetchUser(2);
  const user3 = await fetchUser(3);
  
  return [user1, user2, user3];
}

// Or using for loop
async function processUsersSequentially(userIds) {
  const results = [];
  for (const id of userIds) {
    const user = await fetchUser(id);
    results.push(user);
  }
  return results;
}
</code></pre>
</div>

<p><strong>204. What happens when you don't await a Promise?</strong></p>

<p>The Promise executes but you don't wait for its completion. This can lead to unhandled rejections and race conditions.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20example()%20%7B%0A%20%20%2F%2F%20Fire%20and%20forget%20-%20dangerous!%0A%20%20someAsyncOperation()%3B%20%2F%2F%20No%20await%0A%20%20%0A%20%20%2F%2F%20This%20might%20execute%20before%20someAsyncOperation%20completes%0A%20%20console.log(%22This%20runs%20immediately%22)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function example() {
  // Fire and forget - dangerous!
  someAsyncOperation(); // No await
  
  // This might execute before someAsyncOperation completes
  console.log("This runs immediately");
}
</code></pre>
</div>

<p><strong>205. How do you convert callback-based functions to Promises?</strong></p>

<p>Use the Promise constructor or Node.js `util.promisify()`.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20Manual%20conversion%0Afunction%20readFilePromise(filename)%20%7B%0A%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20fs.readFile(filename%2C%20'utf8'%2C%20(err%2C%20data)%20%3D%3E%20%7B%0A%20%20%20%20%20%20if%20(err)%20reject(err)%3B%0A%20%20%20%20%20%20else%20resolve(data)%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D)%3B%0A%7D%0A%0A%2F%2F%20Using%20util.promisify%0Aconst%20%7B%20promisify%20%7D%20%3D%20require('util')%3B%0Aconst%20readFileAsync%20%3D%20promisify(fs.readFile)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// Manual conversion
function readFilePromise(filename) {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(filename, 'utf8', (err, data) =&gt; {
      if (err) reject(err);
      else resolve(data);
    });
  });
}

// Using util.promisify
const { promisify } = require('util');
const readFileAsync = promisify(fs.readFile);
</code></pre>
</div>

<p><strong>206. How do you implement a delay function using Promises?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="function%20delay(ms)%20%7B%0A%20%20return%20new%20Promise(resolve%20%3D%3E%20setTimeout(resolve%2C%20ms))%3B%0A%7D%0A%0A%2F%2F%20Usage%0Aasync%20function%20example()%20%7B%0A%20%20console.log(%22Start%22)%3B%0A%20%20await%20delay(2000)%3B%0A%20%20console.log(%222%20seconds%20later%22)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">function delay(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

// Usage
async function example() {
  console.log("Start");
  await delay(2000);
  console.log("2 seconds later");
}
</code></pre>
</div>

<p><strong>207. How do you implement timeout for Promises?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="function%20withTimeout(promise%2C%20ms)%20%7B%0A%20%20const%20timeout%20%3D%20new%20Promise((_%2C%20reject)%20%3D%3E%0A%20%20%20%20setTimeout(()%20%3D%3E%20reject(new%20Error('Timeout'))%2C%20ms)%0A%20%20)%3B%0A%20%20%0A%20%20return%20Promise.race(%5Bpromise%2C%20timeout%5D)%3B%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20result%20%3D%20await%20withTimeout(fetch('%2Fapi%2Fdata')%2C%205000)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) =&gt;
    setTimeout(() =&gt; reject(new Error('Timeout')), ms)
  );
  
  return Promise.race([promise, timeout]);
}

// Usage
const result = await withTimeout(fetch('/api/data'), 5000);
</code></pre>
</div>

<p><strong>208. How do you implement retry logic for failed async operations?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20retry(fn%2C%20maxAttempts%20%3D%203%2C%20delay%20%3D%201000)%20%7B%0A%20%20for%20(let%20attempt%20%3D%201%3B%20attempt%20%3C%3D%20maxAttempts%3B%20attempt%2B%2B)%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20return%20await%20fn()%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20if%20(attempt%20%3D%3D%3D%20maxAttempts)%20throw%20error%3B%0A%20%20%20%20%20%20await%20new%20Promise(resolve%20%3D%3E%20setTimeout(resolve%2C%20delay))%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20result%20%3D%20await%20retry(()%20%3D%3E%20fetch('%2Fapi%2Fdata')%2C%203%2C%202000)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function retry(fn, maxAttempts = 3, delay = 1000) {
  for (let attempt = 1; attempt &lt;= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      await new Promise(resolve =&gt; setTimeout(resolve, delay));
    }
  }
}

// Usage
const result = await retry(() =&gt; fetch('/api/data'), 3, 2000);
</code></pre>
</div>

<p><strong>209. How do you handle multiple async operations with different error handling?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20handleMultipleOperations()%20%7B%0A%20%20const%20results%20%3D%20await%20Promise.allSettled(%5B%0A%20%20%20%20criticalOperation()%2C%0A%20%20%20%20optionalOperation()%2C%0A%20%20%20%20anotherOperation()%0A%20%20%5D)%3B%0A%20%20%0A%20%20results.forEach((result%2C%20index)%20%3D%3E%20%7B%0A%20%20%20%20if%20(result.status%20%3D%3D%3D%20'rejected')%20%7B%0A%20%20%20%20%20%20if%20(index%20%3D%3D%3D%200)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Critical%20operation%20failed%0A%20%20%20%20%20%20%20%20throw%20new%20Error('Critical%20operation%20failed')%3B%0A%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Log%20non-critical%20failures%0A%20%20%20%20%20%20%20%20console.warn(%60Operation%20%24%7Bindex%7D%20failed%3A%60%2C%20result.reason)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D)%3B%0A%20%20%0A%20%20return%20results.filter(r%20%3D%3E%20r.status%20%3D%3D%3D%20'fulfilled').map(r%20%3D%3E%20r.value)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function handleMultipleOperations() {
  const results = await Promise.allSettled([
    criticalOperation(),
    optionalOperation(),
    anotherOperation()
  ]);
  
  results.forEach((result, index) =&gt; {
    if (result.status === 'rejected') {
      if (index === 0) {
        // Critical operation failed
        throw new Error('Critical operation failed');
      } else {
        // Log non-critical failures
        console.warn(`Operation ${index} failed:`, result.reason);
      }
    }
  });
  
  return results.filter(r =&gt; r.status === 'fulfilled').map(r =&gt; r.value);
}
</code></pre>
</div>

<p><strong>210. How do you implement Promise cancellation?</strong></p>

<p>JavaScript Promises aren't natively cancellable, but you can implement cancellation patterns.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="function%20cancellablePromise(asyncFn)%20%7B%0A%20%20let%20cancelled%20%3D%20false%3B%0A%20%20%0A%20%20const%20promise%20%3D%20new%20Promise(async%20(resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20asyncFn()%3B%0A%20%20%20%20%20%20if%20(!cancelled)%20resolve(result)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20if%20(!cancelled)%20reject(error)%3B%0A%20%20%20%20%7D%0A%20%20%7D)%3B%0A%20%20%0A%20%20return%20%7B%0A%20%20%20%20promise%2C%0A%20%20%20%20cancel%3A%20()%20%3D%3E%20%7B%20cancelled%20%3D%20true%3B%20%7D%0A%20%20%7D%3B%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20%7B%20promise%2C%20cancel%20%7D%20%3D%20cancellablePromise(()%20%3D%3E%20fetch('%2Fapi%2Fdata'))%3B%0AsetTimeout(cancel%2C%201000)%3B%20%2F%2F%20Cancel%20after%201%20second%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">function cancellablePromise(asyncFn) {
  let cancelled = false;
  
  const promise = new Promise(async (resolve, reject) =&gt; {
    try {
      const result = await asyncFn();
      if (!cancelled) resolve(result);
    } catch (error) {
      if (!cancelled) reject(error);
    }
  });
  
  return {
    promise,
    cancel: () =&gt; { cancelled = true; }
  };
}

// Usage
const { promise, cancel } = cancellablePromise(() =&gt; fetch('/api/data'));
setTimeout(cancel, 1000); // Cancel after 1 second
</code></pre>
</div>

<p><strong>211. What is the difference between parallel and sequential execution?</strong></p>

<p><strong>Parallel:</strong> Operations run simultaneously, completing faster but using more resources.</p>
<p><strong>Sequential:</strong> Operations run one after another, taking longer but using fewer resources.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20Parallel%20-%20faster%0Aasync%20function%20parallel()%20%7B%0A%20%20const%20%5Ba%2C%20b%2C%20c%5D%20%3D%20await%20Promise.all(%5B%0A%20%20%20%20operation1()%2C%20%2F%2F%20All%20start%20together%0A%20%20%20%20operation2()%2C%0A%20%20%20%20operation3()%0A%20%20%5D)%3B%0A%7D%0A%0A%2F%2F%20Sequential%20-%20slower%20but%20controlled%0Aasync%20function%20sequential()%20%7B%0A%20%20const%20a%20%3D%20await%20operation1()%3B%20%2F%2F%20Waits%20for%20completion%0A%20%20const%20b%20%3D%20await%20operation2()%3B%20%2F%2F%20Then%20starts%20this%0A%20%20const%20c%20%3D%20await%20operation3()%3B%20%2F%2F%20Then%20starts%20this%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// Parallel - faster
async function parallel() {
  const [a, b, c] = await Promise.all([
    operation1(), // All start together
    operation2(),
    operation3()
  ]);
}

// Sequential - slower but controlled
async function sequential() {
  const a = await operation1(); // Waits for completion
  const b = await operation2(); // Then starts this
  const c = await operation3(); // Then starts this
}
</code></pre>
</div>

<p><strong>212. How do you implement exponential backoff for retries?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20exponentialBackoff(fn%2C%20maxAttempts%20%3D%205%2C%20baseDelay%20%3D%201000)%20%7B%0A%20%20for%20(let%20attempt%20%3D%201%3B%20attempt%20%3C%3D%20maxAttempts%3B%20attempt%2B%2B)%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20return%20await%20fn()%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20if%20(attempt%20%3D%3D%3D%20maxAttempts)%20throw%20error%3B%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20const%20delay%20%3D%20baseDelay%20*%20Math.pow(2%2C%20attempt%20-%201)%3B%0A%20%20%20%20%20%20const%20jitter%20%3D%20Math.random()%20*%201000%3B%20%2F%2F%20Add%20randomness%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20await%20new%20Promise(resolve%20%3D%3E%20%0A%20%20%20%20%20%20%20%20setTimeout(resolve%2C%20delay%20%2B%20jitter)%0A%20%20%20%20%20%20)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function exponentialBackoff(fn, maxAttempts = 5, baseDelay = 1000) {
  for (let attempt = 1; attempt &lt;= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      
      const delay = baseDelay * Math.pow(2, attempt - 1);
      const jitter = Math.random() * 1000; // Add randomness
      
      await new Promise(resolve =&gt; 
        setTimeout(resolve, delay + jitter)
      );
    }
  }
}
</code></pre>
</div>

<p><strong>213. How do you batch async operations with concurrency limits?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20batchWithConcurrency(items%2C%20asyncFn%2C%20concurrency%20%3D%203)%20%7B%0A%20%20const%20results%20%3D%20%5B%5D%3B%0A%20%20%0A%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20items.length%3B%20i%20%2B%3D%20concurrency)%20%7B%0A%20%20%20%20const%20batch%20%3D%20items.slice(i%2C%20i%20%2B%20concurrency)%3B%0A%20%20%20%20const%20batchResults%20%3D%20await%20Promise.all(%0A%20%20%20%20%20%20batch.map(item%20%3D%3E%20asyncFn(item))%0A%20%20%20%20)%3B%0A%20%20%20%20results.push(...batchResults)%3B%0A%20%20%7D%0A%20%20%0A%20%20return%20results%3B%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20results%20%3D%20await%20batchWithConcurrency(%0A%20%20userIds%2C%20%0A%20%20fetchUser%2C%20%0A%20%205%20%2F%2F%20Process%205%20users%20at%20a%20time%0A)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function batchWithConcurrency(items, asyncFn, concurrency = 3) {
  const results = [];
  
  for (let i = 0; i &lt; items.length; i += concurrency) {
    const batch = items.slice(i, i + concurrency);
    const batchResults = await Promise.all(
      batch.map(item =&gt; asyncFn(item))
    );
    results.push(...batchResults);
  }
  
  return results;
}

// Usage
const results = await batchWithConcurrency(
  userIds, 
  fetchUser, 
  5 // Process 5 users at a time
);
</code></pre>
</div>

<p><strong>214. How do you implement async queues?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncQueue%20%7B%0A%20%20constructor(concurrency%20%3D%201)%20%7B%0A%20%20%20%20this.concurrency%20%3D%20concurrency%3B%0A%20%20%20%20this.running%20%3D%200%3B%0A%20%20%20%20this.queue%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20add(asyncFn)%20%7B%0A%20%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20%20%20this.queue.push(%7B%0A%20%20%20%20%20%20%20%20asyncFn%2C%0A%20%20%20%20%20%20%20%20resolve%2C%0A%20%20%20%20%20%20%20%20reject%0A%20%20%20%20%20%20%7D)%3B%0A%20%20%20%20%20%20this.process()%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20process()%20%7B%0A%20%20%20%20if%20(this.running%20%3E%3D%20this.concurrency%20%7C%7C%20this.queue.length%20%3D%3D%3D%200)%20%7B%0A%20%20%20%20%20%20return%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20this.running%2B%2B%3B%0A%20%20%20%20const%20%7B%20asyncFn%2C%20resolve%2C%20reject%20%7D%20%3D%20this.queue.shift()%3B%0A%20%20%20%20%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20asyncFn()%3B%0A%20%20%20%20%20%20resolve(result)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20reject(error)%3B%0A%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20this.running--%3B%0A%20%20%20%20%20%20this.process()%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async add(asyncFn) {
    return new Promise((resolve, reject) =&gt; {
      this.queue.push({
        asyncFn,
        resolve,
        reject
      });
      this.process();
    });
  }
  
  async process() {
    if (this.running &gt;= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { asyncFn, resolve, reject } = this.queue.shift();
    
    try {
      const result = await asyncFn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}
</code></pre>
</div>

<p><strong>215. How do you handle race conditions in async code?</strong></p>

<p>Use locks, semaphores, or atomic operations to prevent race conditions.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncLock%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20this.locked%20%3D%20false%3B%0A%20%20%20%20this.queue%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20acquire()%20%7B%0A%20%20%20%20return%20new%20Promise(resolve%20%3D%3E%20%7B%0A%20%20%20%20%20%20if%20(!this.locked)%20%7B%0A%20%20%20%20%20%20%20%20this.locked%20%3D%20true%3B%0A%20%20%20%20%20%20%20%20resolve()%3B%0A%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20this.queue.push(resolve)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20release()%20%7B%0A%20%20%20%20if%20(this.queue.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20const%20next%20%3D%20this.queue.shift()%3B%0A%20%20%20%20%20%20next()%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20this.locked%20%3D%20false%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20lock%20%3D%20new%20AsyncLock()%3B%0A%0Aasync%20function%20criticalSection()%20%7B%0A%20%20await%20lock.acquire()%3B%0A%20%20try%20%7B%0A%20%20%20%20%2F%2F%20Critical%20code%20here%0A%20%20%20%20await%20someAsyncOperation()%3B%0A%20%20%7D%20finally%20%7B%0A%20%20%20%20lock.release()%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncLock {
  constructor() {
    this.locked = false;
    this.queue = [];
  }
  
  async acquire() {
    return new Promise(resolve =&gt; {
      if (!this.locked) {
        this.locked = true;
        resolve();
      } else {
        this.queue.push(resolve);
      }
    });
  }
  
  release() {
    if (this.queue.length &gt; 0) {
      const next = this.queue.shift();
      next();
    } else {
      this.locked = false;
    }
  }
}

// Usage
const lock = new AsyncLock();

async function criticalSection() {
  await lock.acquire();
  try {
    // Critical code here
    await someAsyncOperation();
  } finally {
    lock.release();
  }
}
</code></pre>
</div>

<h2 id="-advanced-patterns-25-questions-">**Advanced Patterns (25 Questions)**</h2>

<p><strong>216. What is callback hell and how do you avoid it?</strong></p>

<p>Callback hell is deeply nested callbacks that make code hard to read and maintain.</p>

<p><strong>Example of callback hell:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="getData(function(a)%20%7B%0A%20%20getMoreData(a%2C%20function(b)%20%7B%0A%20%20%20%20getEvenMoreData(b%2C%20function(c)%20%7B%0A%20%20%20%20%20%20%2F%2F%20This%20keeps%20going...%0A%20%20%20%20%7D)%3B%0A%20%20%7D)%3B%0A%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">getData(function(a) {
  getMoreData(a, function(b) {
    getEvenMoreData(b, function(c) {
      // This keeps going...
    });
  });
});
</code></pre>
</div>

<p><strong>Solutions:</strong></p>

<p>- Use Promises and async/await</p>
<p>- Modularize functions</p>
<p>- Use libraries like async.js</p>


<p><strong>217. What are microtasks and macrotasks in the event loop?</strong></p>

<p><strong>Microtasks:</strong> Higher priority tasks (Promise callbacks, queueMicrotask)</p>
<p><strong>Macrotasks:</strong> Lower priority tasks (setTimeout, setInterval, I/O)</p>

<p><strong>Execution order:</strong> All microtasks execute before the next macrotask.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="console.log('1')%3B%0AsetTimeout(()%20%3D%3E%20console.log('2')%2C%200)%3B%20%2F%2F%20Macrotask%0APromise.resolve().then(()%20%3D%3E%20console.log('3'))%3B%20%2F%2F%20Microtask%0Aconsole.log('4')%3B%0A%2F%2F%20Output%3A%201%2C%204%2C%203%2C%202%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">console.log('1');
setTimeout(() =&gt; console.log('2'), 0); // Macrotask
Promise.resolve().then(() =&gt; console.log('3')); // Microtask
console.log('4');
// Output: 1, 4, 3, 2
</code></pre>
</div>

<p><strong>218. What are async generators and how do you use them?</strong></p>

<p>Async generators combine generators with async/await, yielding promises.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function*%20asyncGenerator()%20%7B%0A%20%20yield%20await%20fetch('%2Fapi%2Fdata1')%3B%0A%20%20yield%20await%20fetch('%2Fapi%2Fdata2')%3B%0A%20%20yield%20await%20fetch('%2Fapi%2Fdata3')%3B%0A%7D%0A%0A%2F%2F%20Usage%0Afor%20await%20(const%20data%20of%20asyncGenerator())%20%7B%0A%20%20console.log(await%20data.json())%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function* asyncGenerator() {
  yield await fetch('/api/data1');
  yield await fetch('/api/data2');
  yield await fetch('/api/data3');
}

// Usage
for await (const data of asyncGenerator()) {
  console.log(await data.json());
}
</code></pre>
</div>

<p><strong>219. What are async iterators?</strong></p>

<p>Objects that implement the async iteration protocol with `Symbol.asyncIterator`.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20asyncIterable%20%3D%20%7B%0A%20%20async%20*%5BSymbol.asyncIterator%5D()%20%7B%0A%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%203%3B%20i%2B%2B)%20%7B%0A%20%20%20%20%20%20await%20new%20Promise(resolve%20%3D%3E%20setTimeout(resolve%2C%201000))%3B%0A%20%20%20%20%20%20yield%20i%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%3B%0A%0Afor%20await%20(const%20value%20of%20asyncIterable)%20%7B%0A%20%20console.log(value)%3B%20%2F%2F%200%2C%201%2C%202%20(with%201s%20delays)%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const asyncIterable = {
  async *[Symbol.asyncIterator]() {
    for (let i = 0; i &lt; 3; i++) {
      await new Promise(resolve =&gt; setTimeout(resolve, 1000));
      yield i;
    }
  }
};

for await (const value of asyncIterable) {
  console.log(value); // 0, 1, 2 (with 1s delays)
}
</code></pre>
</div>

<p><strong>220. What is the difference between `for await...of` and normal `for...of`?</strong></p>

<p><strong>`for...of`:</strong> Synchronous iteration over iterable objects</p>
<p><strong>`for await...of`:</strong> Asynchronous iteration over async iterables</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20Synchronous%0Afor%20(const%20item%20of%20%5B1%2C%202%2C%203%5D)%20%7B%0A%20%20console.log(item)%3B%0A%7D%0A%0A%2F%2F%20Asynchronous%0Afor%20await%20(const%20item%20of%20asyncIterable)%20%7B%0A%20%20console.log(item)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// Synchronous
for (const item of [1, 2, 3]) {
  console.log(item);
}

// Asynchronous
for await (const item of asyncIterable) {
  console.log(item);
}
</code></pre>
</div>

<p><strong>221. How do you implement custom async iterators?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncRange%20%7B%0A%20%20constructor(start%2C%20end%2C%20delay%20%3D%201000)%20%7B%0A%20%20%20%20this.start%20%3D%20start%3B%0A%20%20%20%20this.end%20%3D%20end%3B%0A%20%20%20%20this.delay%20%3D%20delay%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20*%5BSymbol.asyncIterator%5D()%20%7B%0A%20%20%20%20for%20(let%20i%20%3D%20this.start%3B%20i%20%3C%3D%20this.end%3B%20i%2B%2B)%20%7B%0A%20%20%20%20%20%20await%20new%20Promise(resolve%20%3D%3E%20setTimeout(resolve%2C%20this.delay))%3B%0A%20%20%20%20%20%20yield%20i%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20range%20%3D%20new%20AsyncRange(1%2C%205%2C%20500)%3B%0Afor%20await%20(const%20num%20of%20range)%20%7B%0A%20%20console.log(num)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncRange {
  constructor(start, end, delay = 1000) {
    this.start = start;
    this.end = end;
    this.delay = delay;
  }
  
  async *[Symbol.asyncIterator]() {
    for (let i = this.start; i &lt;= this.end; i++) {
      await new Promise(resolve =&gt; setTimeout(resolve, this.delay));
      yield i;
    }
  }
}

// Usage
const range = new AsyncRange(1, 5, 500);
for await (const num of range) {
  console.log(num);
}
</code></pre>
</div>

<p><strong>222. What is throttling vs debouncing in async operations?</strong></p>

<p><strong>Throttling:</strong> Limits execution frequency (max once per time period)</p>
<p><strong>Debouncing:</strong> Delays execution until after a quiet period</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20Throttling%0Afunction%20throttle(fn%2C%20delay)%20%7B%0A%20%20let%20lastCall%20%3D%200%3B%0A%20%20return%20function(...args)%20%7B%0A%20%20%20%20const%20now%20%3D%20Date.now()%3B%0A%20%20%20%20if%20(now%20-%20lastCall%20%3E%3D%20delay)%20%7B%0A%20%20%20%20%20%20lastCall%20%3D%20now%3B%0A%20%20%20%20%20%20return%20fn.apply(this%2C%20args)%3B%0A%20%20%20%20%7D%0A%20%20%7D%3B%0A%7D%0A%0A%2F%2F%20Debouncing%0Afunction%20debounce(fn%2C%20delay)%20%7B%0A%20%20let%20timeoutId%3B%0A%20%20return%20function(...args)%20%7B%0A%20%20%20%20clearTimeout(timeoutId)%3B%0A%20%20%20%20timeoutId%20%3D%20setTimeout(()%20%3D%3E%20fn.apply(this%2C%20args)%2C%20delay)%3B%0A%20%20%7D%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// Throttling
function throttle(fn, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall &gt;= delay) {
      lastCall = now;
      return fn.apply(this, args);
    }
  };
}

// Debouncing
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() =&gt; fn.apply(this, args), delay);
  };
}
</code></pre>
</div>

<p><strong>223. How do you implement async middleware patterns?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncMiddleware%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20this.middlewares%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20use(fn)%20%7B%0A%20%20%20%20this.middlewares.push(fn)%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20execute(context)%20%7B%0A%20%20%20%20let%20index%20%3D%200%3B%0A%20%20%20%20%0A%20%20%20%20const%20next%20%3D%20async%20()%20%3D%3E%20%7B%0A%20%20%20%20%20%20if%20(index%20%3C%20this.middlewares.length)%20%7B%0A%20%20%20%20%20%20%20%20const%20middleware%20%3D%20this.middlewares%5Bindex%2B%2B%5D%3B%0A%20%20%20%20%20%20%20%20await%20middleware(context%2C%20next)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20await%20next()%3B%0A%20%20%7D%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20middleware%20%3D%20new%20AsyncMiddleware()%3B%0Amiddleware.use(async%20(ctx%2C%20next)%20%3D%3E%20%7B%0A%20%20console.log('Before')%3B%0A%20%20await%20next()%3B%0A%20%20console.log('After')%3B%0A%7D)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncMiddleware {
  constructor() {
    this.middlewares = [];
  }
  
  use(fn) {
    this.middlewares.push(fn);
  }
  
  async execute(context) {
    let index = 0;
    
    const next = async () =&gt; {
      if (index &lt; this.middlewares.length) {
        const middleware = this.middlewares[index++];
        await middleware(context, next);
      }
    };
    
    await next();
  }
}

// Usage
const middleware = new AsyncMiddleware();
middleware.use(async (ctx, next) =&gt; {
  console.log('Before');
  await next();
  console.log('After');
});
</code></pre>
</div>

<p><strong>224. What are observables and how do they differ from Promises?</strong></p>

<p><strong>Observables:</strong> Handle multiple values over time, cancellable, lazy</p>
<p><strong>Promises:</strong> Handle single value, not cancellable, eager</p>

<p><strong>Key differences:</strong></p>

<p>- Observables can emit multiple values</p>
<p>- Observables are cancellable</p>
<p>- Observables are lazy (don't execute until subscribed)</p>


<p><strong>225. How do you handle async operations in event-driven programming?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20EventEmitter%20%3D%20require('events')%3B%0A%0Aclass%20AsyncEventHandler%20extends%20EventEmitter%20%7B%0A%20%20async%20handleEvent(eventName%2C%20data)%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20this.processAsync(data)%3B%0A%20%20%20%20%20%20this.emit('success'%2C%20result)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20this.emit('error'%2C%20error)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20async%20processAsync(data)%20%7B%0A%20%20%20%20%2F%2F%20Async%20processing%0A%20%20%20%20return%20await%20someAsyncOperation(data)%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const EventEmitter = require('events');

class AsyncEventHandler extends EventEmitter {
  async handleEvent(eventName, data) {
    try {
      const result = await this.processAsync(data);
      this.emit('success', result);
    } catch (error) {
      this.emit('error', error);
    }
  }
  
  async processAsync(data) {
    // Async processing
    return await someAsyncOperation(data);
  }
}
</code></pre>
</div>

<p><strong>226. What are worker pools and when do you use them?</strong></p>

<p>Worker pools manage a set of worker threads for CPU-intensive tasks.</p>

<p><strong>Use cases:</strong></p>

<p>- CPU-intensive computations</p>
<p>- Image/video processing</p>
<p>- Cryptographic operations</p>


<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20%7B%20Worker%2C%20isMainThread%2C%20parentPort%20%7D%20%3D%20require('worker_threads')%3B%0A%0Aif%20(isMainThread)%20%7B%0A%20%20%2F%2F%20Main%20thread%20-%20create%20worker%20pool%0A%20%20class%20WorkerPool%20%7B%0A%20%20%20%20constructor(size%2C%20workerScript)%20%7B%0A%20%20%20%20%20%20this.workers%20%3D%20%5B%5D%3B%0A%20%20%20%20%20%20this.queue%20%3D%20%5B%5D%3B%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20size%3B%20i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20this.workers.push(new%20Worker(workerScript))%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20async%20execute(data)%20%7B%0A%20%20%20%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20const%20worker%20%3D%20this.workers.pop()%3B%0A%20%20%20%20%20%20%20%20if%20(worker)%20%7B%0A%20%20%20%20%20%20%20%20%20%20worker.postMessage(data)%3B%0A%20%20%20%20%20%20%20%20%20%20worker.once('message'%2C%20resolve)%3B%0A%20%20%20%20%20%20%20%20%20%20worker.once('error'%2C%20reject)%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20this.queue.push(%7B%20data%2C%20resolve%2C%20reject%20%7D)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%20else%20%7B%0A%20%20%2F%2F%20Worker%20thread%0A%20%20parentPort.on('message'%2C%20async%20(data)%20%3D%3E%20%7B%0A%20%20%20%20const%20result%20%3D%20await%20heavyComputation(data)%3B%0A%20%20%20%20parentPort.postMessage(result)%3B%0A%20%20%7D)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
  // Main thread - create worker pool
  class WorkerPool {
    constructor(size, workerScript) {
      this.workers = [];
      this.queue = [];
      
      for (let i = 0; i &lt; size; i++) {
        this.workers.push(new Worker(workerScript));
      }
    }
    
    async execute(data) {
      return new Promise((resolve, reject) =&gt; {
        const worker = this.workers.pop();
        if (worker) {
          worker.postMessage(data);
          worker.once('message', resolve);
          worker.once('error', reject);
        } else {
          this.queue.push({ data, resolve, reject });
        }
      });
    }
  }
} else {
  // Worker thread
  parentPort.on('message', async (data) =&gt; {
    const result = await heavyComputation(data);
    parentPort.postMessage(result);
  });
}
</code></pre>
</div>

<p><strong>227. How do you prevent memory leaks in async code?</strong></p>

<p><strong>Common causes and solutions:</strong></p>

<p>- <strong>Unclosed resources:</strong> Always close files, connections, streams</p>
<p>- <strong>Event listeners:</strong> Remove listeners when done</p>
<p>- <strong>Timers:</strong> Clear timeouts and intervals</p>
<p>- <strong>Promises:</strong> Handle rejections</p>


<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20ResourceManager%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20this.resources%20%3D%20new%20Set()%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20createResource()%20%7B%0A%20%20%20%20const%20resource%20%3D%20await%20openResource()%3B%0A%20%20%20%20this.resources.add(resource)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Auto-cleanup%20after%20timeout%0A%20%20%20%20setTimeout(()%20%3D%3E%20%7B%0A%20%20%20%20%20%20this.cleanup(resource)%3B%0A%20%20%20%20%7D%2C%20300000)%3B%20%2F%2F%205%20minutes%0A%20%20%20%20%0A%20%20%20%20return%20resource%3B%0A%20%20%7D%0A%20%20%0A%20%20cleanup(resource)%20%7B%0A%20%20%20%20if%20(this.resources.has(resource))%20%7B%0A%20%20%20%20%20%20resource.close()%3B%0A%20%20%20%20%20%20this.resources.delete(resource)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20async%20cleanupAll()%20%7B%0A%20%20%20%20for%20(const%20resource%20of%20this.resources)%20%7B%0A%20%20%20%20%20%20await%20resource.close()%3B%0A%20%20%20%20%7D%0A%20%20%20%20this.resources.clear()%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class ResourceManager {
  constructor() {
    this.resources = new Set();
  }
  
  async createResource() {
    const resource = await openResource();
    this.resources.add(resource);
    
    // Auto-cleanup after timeout
    setTimeout(() =&gt; {
      this.cleanup(resource);
    }, 300000); // 5 minutes
    
    return resource;
  }
  
  cleanup(resource) {
    if (this.resources.has(resource)) {
      resource.close();
      this.resources.delete(resource);
    }
  }
  
  async cleanupAll() {
    for (const resource of this.resources) {
      await resource.close();
    }
    this.resources.clear();
  }
}
</code></pre>
</div>

<p><strong>228. What is deadlock and can it occur in async code?</strong></p>

<p>Deadlock occurs when two or more operations wait for each other indefinitely.</p>

<p><strong>Yes, it can occur in async code:</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20Deadlock%20scenario%0Alet%20lock1%20%3D%20false%2C%20lock2%20%3D%20false%3B%0A%0Aasync%20function%20task1()%20%7B%0A%20%20while%20(lock1)%20await%20delay(10)%3B%0A%20%20lock1%20%3D%20true%3B%0A%20%20%0A%20%20while%20(lock2)%20await%20delay(10)%3B%20%2F%2F%20Waits%20for%20task2%0A%20%20lock2%20%3D%20true%3B%0A%20%20%0A%20%20%2F%2F%20Do%20work%0A%20%20lock2%20%3D%20false%3B%0A%20%20lock1%20%3D%20false%3B%0A%7D%0A%0Aasync%20function%20task2()%20%7B%0A%20%20while%20(lock2)%20await%20delay(10)%3B%0A%20%20lock2%20%3D%20true%3B%0A%20%20%0A%20%20while%20(lock1)%20await%20delay(10)%3B%20%2F%2F%20Waits%20for%20task1%0A%20%20lock1%20%3D%20true%3B%0A%20%20%0A%20%20%2F%2F%20Do%20work%0A%20%20lock1%20%3D%20false%3B%0A%20%20lock2%20%3D%20false%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// Deadlock scenario
let lock1 = false, lock2 = false;

async function task1() {
  while (lock1) await delay(10);
  lock1 = true;
  
  while (lock2) await delay(10); // Waits for task2
  lock2 = true;
  
  // Do work
  lock2 = false;
  lock1 = false;
}

async function task2() {
  while (lock2) await delay(10);
  lock2 = true;
  
  while (lock1) await delay(10); // Waits for task1
  lock1 = true;
  
  // Do work
  lock1 = false;
  lock2 = false;
}
</code></pre>
</div>

<p><strong>Prevention:</strong> Use timeout mechanisms, ordered locking, or avoid nested locks.</p>

<p><strong>229. How do you implement circuit breaker patterns?</strong></p>

<p>Circuit breakers prevent cascading failures by stopping requests to failing services.</p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20CircuitBreaker%20%7B%0A%20%20constructor(threshold%20%3D%205%2C%20timeout%20%3D%2060000)%20%7B%0A%20%20%20%20this.threshold%20%3D%20threshold%3B%0A%20%20%20%20this.timeout%20%3D%20timeout%3B%0A%20%20%20%20this.failureCount%20%3D%200%3B%0A%20%20%20%20this.state%20%3D%20'CLOSED'%3B%20%2F%2F%20CLOSED%2C%20OPEN%2C%20HALF_OPEN%0A%20%20%20%20this.nextAttempt%20%3D%20Date.now()%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20call(fn)%20%7B%0A%20%20%20%20if%20(this.state%20%3D%3D%3D%20'OPEN')%20%7B%0A%20%20%20%20%20%20if%20(Date.now()%20%3C%20this.nextAttempt)%20%7B%0A%20%20%20%20%20%20%20%20throw%20new%20Error('Circuit%20breaker%20is%20OPEN')%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20this.state%20%3D%20'HALF_OPEN'%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20fn()%3B%0A%20%20%20%20%20%20this.onSuccess()%3B%0A%20%20%20%20%20%20return%20result%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20this.onFailure()%3B%0A%20%20%20%20%20%20throw%20error%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20onSuccess()%20%7B%0A%20%20%20%20this.failureCount%20%3D%200%3B%0A%20%20%20%20this.state%20%3D%20'CLOSED'%3B%0A%20%20%7D%0A%20%20%0A%20%20onFailure()%20%7B%0A%20%20%20%20this.failureCount%2B%2B%3B%0A%20%20%20%20if%20(this.failureCount%20%3E%3D%20this.threshold)%20%7B%0A%20%20%20%20%20%20this.state%20%3D%20'OPEN'%3B%0A%20%20%20%20%20%20this.nextAttempt%20%3D%20Date.now()%20%2B%20this.timeout%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.threshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }
  
  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() &lt; this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount &gt;= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}
</code></pre>
</div>

<p><strong>230. How do you handle async operations with timeouts?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="async%20function%20withTimeout(asyncFn%2C%20timeoutMs)%20%7B%0A%20%20const%20timeoutPromise%20%3D%20new%20Promise((_%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20setTimeout(()%20%3D%3E%20reject(new%20Error('Operation%20timed%20out'))%2C%20timeoutMs)%3B%0A%20%20%7D)%3B%0A%20%20%0A%20%20return%20Promise.race(%5BasyncFn()%2C%20timeoutPromise%5D)%3B%0A%7D%0A%0A%2F%2F%20Usage%0Atry%20%7B%0A%20%20const%20result%20%3D%20await%20withTimeout(%0A%20%20%20%20()%20%3D%3E%20fetch('%2Fapi%2Fslow-endpoint')%2C%0A%20%20%20%205000%0A%20%20)%3B%0A%7D%20catch%20(error)%20%7B%0A%20%20if%20(error.message%20%3D%3D%3D%20'Operation%20timed%20out')%20%7B%0A%20%20%20%20%2F%2F%20Handle%20timeout%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">async function withTimeout(asyncFn, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) =&gt; {
    setTimeout(() =&gt; reject(new Error('Operation timed out')), timeoutMs);
  });
  
  return Promise.race([asyncFn(), timeoutPromise]);
}

// Usage
try {
  const result = await withTimeout(
    () =&gt; fetch('/api/slow-endpoint'),
    5000
  );
} catch (error) {
  if (error.message === 'Operation timed out') {
    // Handle timeout
  }
}
</code></pre>
</div>

<p><strong>231. How do you implement async resource pooling?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncResourcePool%20%7B%0A%20%20constructor(createResource%2C%20maxSize%20%3D%2010)%20%7B%0A%20%20%20%20this.createResource%20%3D%20createResource%3B%0A%20%20%20%20this.maxSize%20%3D%20maxSize%3B%0A%20%20%20%20this.available%20%3D%20%5B%5D%3B%0A%20%20%20%20this.inUse%20%3D%20new%20Set()%3B%0A%20%20%20%20this.waiting%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20acquire()%20%7B%0A%20%20%20%20if%20(this.available.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20const%20resource%20%3D%20this.available.pop()%3B%0A%20%20%20%20%20%20this.inUse.add(resource)%3B%0A%20%20%20%20%20%20return%20resource%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20if%20(this.inUse.size%20%3C%20this.maxSize)%20%7B%0A%20%20%20%20%20%20const%20resource%20%3D%20await%20this.createResource()%3B%0A%20%20%20%20%20%20this.inUse.add(resource)%3B%0A%20%20%20%20%20%20return%20resource%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Wait%20for%20available%20resource%0A%20%20%20%20return%20new%20Promise(resolve%20%3D%3E%20%7B%0A%20%20%20%20%20%20this.waiting.push(resolve)%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20release(resource)%20%7B%0A%20%20%20%20this.inUse.delete(resource)%3B%0A%20%20%20%20%0A%20%20%20%20if%20(this.waiting.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20const%20resolve%20%3D%20this.waiting.shift()%3B%0A%20%20%20%20%20%20this.inUse.add(resource)%3B%0A%20%20%20%20%20%20resolve(resource)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20this.available.push(resource)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncResourcePool {
  constructor(createResource, maxSize = 10) {
    this.createResource = createResource;
    this.maxSize = maxSize;
    this.available = [];
    this.inUse = new Set();
    this.waiting = [];
  }
  
  async acquire() {
    if (this.available.length &gt; 0) {
      const resource = this.available.pop();
      this.inUse.add(resource);
      return resource;
    }
    
    if (this.inUse.size &lt; this.maxSize) {
      const resource = await this.createResource();
      this.inUse.add(resource);
      return resource;
    }
    
    // Wait for available resource
    return new Promise(resolve =&gt; {
      this.waiting.push(resolve);
    });
  }
  
  release(resource) {
    this.inUse.delete(resource);
    
    if (this.waiting.length &gt; 0) {
      const resolve = this.waiting.shift();
      this.inUse.add(resource);
      resolve(resource);
    } else {
      this.available.push(resource);
    }
  }
}
</code></pre>
</div>

<p><strong>232. How do you handle async operations in streams?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20%7B%20Transform%20%7D%20%3D%20require('stream')%3B%0A%0Aclass%20AsyncTransform%20extends%20Transform%20%7B%0A%20%20constructor(asyncFn%2C%20options%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20super(%7B%20objectMode%3A%20true%2C%20...options%20%7D)%3B%0A%20%20%20%20this.asyncFn%20%3D%20asyncFn%3B%0A%20%20%20%20this.concurrency%20%3D%20options.concurrency%20%7C%7C%201%3B%0A%20%20%20%20this.processing%20%3D%200%3B%0A%20%20%20%20this.queue%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20_transform(chunk%2C%20encoding%2C%20callback)%20%7B%0A%20%20%20%20this.queue.push(%7B%20chunk%2C%20encoding%2C%20callback%20%7D)%3B%0A%20%20%20%20this.processQueue()%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20processQueue()%20%7B%0A%20%20%20%20if%20(this.processing%20%3E%3D%20this.concurrency%20%7C%7C%20this.queue.length%20%3D%3D%3D%200)%20%7B%0A%20%20%20%20%20%20return%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20this.processing%2B%2B%3B%0A%20%20%20%20const%20%7B%20chunk%2C%20encoding%2C%20callback%20%7D%20%3D%20this.queue.shift()%3B%0A%20%20%20%20%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20this.asyncFn(chunk)%3B%0A%20%20%20%20%20%20callback(null%2C%20result)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20callback(error)%3B%0A%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20this.processing--%3B%0A%20%20%20%20%20%20this.processQueue()%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const { Transform } = require('stream');

class AsyncTransform extends Transform {
  constructor(asyncFn, options = {}) {
    super({ objectMode: true, ...options });
    this.asyncFn = asyncFn;
    this.concurrency = options.concurrency || 1;
    this.processing = 0;
    this.queue = [];
  }
  
  _transform(chunk, encoding, callback) {
    this.queue.push({ chunk, encoding, callback });
    this.processQueue();
  }
  
  async processQueue() {
    if (this.processing &gt;= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.processing++;
    const { chunk, encoding, callback } = this.queue.shift();
    
    try {
      const result = await this.asyncFn(chunk);
      callback(null, result);
    } catch (error) {
      callback(error);
    } finally {
      this.processing--;
      this.processQueue();
    }
  }
}
</code></pre>
</div>

<p><strong>233. How do you implement async event handling?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncEventEmitter%20extends%20EventEmitter%20%7B%0A%20%20async%20emitAsync(event%2C%20...args)%20%7B%0A%20%20%20%20const%20listeners%20%3D%20this.listeners(event)%3B%0A%20%20%20%20const%20promises%20%3D%20listeners.map(listener%20%3D%3E%20%0A%20%20%20%20%20%20Promise.resolve(listener.apply(this%2C%20args))%0A%20%20%20%20)%3B%0A%20%20%20%20%0A%20%20%20%20return%20Promise.all(promises)%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20emitSequential(event%2C%20...args)%20%7B%0A%20%20%20%20const%20listeners%20%3D%20this.listeners(event)%3B%0A%20%20%20%20const%20results%20%3D%20%5B%5D%3B%0A%20%20%20%20%0A%20%20%20%20for%20(const%20listener%20of%20listeners)%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20Promise.resolve(listener.apply(this%2C%20args))%3B%0A%20%20%20%20%20%20results.push(result)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20return%20results%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncEventEmitter extends EventEmitter {
  async emitAsync(event, ...args) {
    const listeners = this.listeners(event);
    const promises = listeners.map(listener =&gt; 
      Promise.resolve(listener.apply(this, args))
    );
    
    return Promise.all(promises);
  }
  
  async emitSequential(event, ...args) {
    const listeners = this.listeners(event);
    const results = [];
    
    for (const listener of listeners) {
      const result = await Promise.resolve(listener.apply(this, args));
      results.push(result);
    }
    
    return results;
  }
}
</code></pre>
</div>

<p><strong>234. How do you handle async operations in cluster environments?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20cluster%20%3D%20require('cluster')%3B%0Aconst%20numCPUs%20%3D%20require('os').cpus().length%3B%0A%0Aif%20(cluster.isMaster)%20%7B%0A%20%20%2F%2F%20Master%20process%0A%20%20const%20workers%20%3D%20%5B%5D%3B%0A%20%20%0A%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20numCPUs%3B%20i%2B%2B)%20%7B%0A%20%20%20%20const%20worker%20%3D%20cluster.fork()%3B%0A%20%20%20%20workers.push(worker)%3B%0A%20%20%7D%0A%20%20%0A%20%20%2F%2F%20Distribute%20async%20tasks%0A%20%20let%20currentWorker%20%3D%200%3B%0A%20%20%0A%20%20function%20distributeTask(task)%20%7B%0A%20%20%20%20const%20worker%20%3D%20workers%5BcurrentWorker%5D%3B%0A%20%20%20%20currentWorker%20%3D%20(currentWorker%20%2B%201)%20%25%20workers.length%3B%0A%20%20%20%20%0A%20%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20%20%20worker.send(%7B%20type%3A%20'task'%2C%20data%3A%20task%20%7D)%3B%0A%20%20%20%20%20%20worker.once('message'%2C%20(result)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20(result.error)%20reject(new%20Error(result.error))%3B%0A%20%20%20%20%20%20%20%20else%20resolve(result.data)%3B%0A%20%20%20%20%20%20%7D)%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%7D%20else%20%7B%0A%20%20%2F%2F%20Worker%20process%0A%20%20process.on('message'%2C%20async%20(message)%20%3D%3E%20%7B%0A%20%20%20%20if%20(message.type%20%3D%3D%3D%20'task')%20%7B%0A%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20const%20result%20%3D%20await%20processTask(message.data)%3B%0A%20%20%20%20%20%20%20%20process.send(%7B%20data%3A%20result%20%7D)%3B%0A%20%20%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%20%20process.send(%7B%20error%3A%20error.message%20%7D)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D)%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // Master process
  const workers = [];
  
  for (let i = 0; i &lt; numCPUs; i++) {
    const worker = cluster.fork();
    workers.push(worker);
  }
  
  // Distribute async tasks
  let currentWorker = 0;
  
  function distributeTask(task) {
    const worker = workers[currentWorker];
    currentWorker = (currentWorker + 1) % workers.length;
    
    return new Promise((resolve, reject) =&gt; {
      worker.send({ type: 'task', data: task });
      worker.once('message', (result) =&gt; {
        if (result.error) reject(new Error(result.error));
        else resolve(result.data);
      });
    });
  }
  
} else {
  // Worker process
  process.on('message', async (message) =&gt; {
    if (message.type === 'task') {
      try {
        const result = await processTask(message.data);
        process.send({ data: result });
      } catch (error) {
        process.send({ error: error.message });
      }
    }
  });
}
</code></pre>
</div>

<p><strong>235. How do you implement async logging without blocking?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncLogger%20%7B%0A%20%20constructor(options%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20this.buffer%20%3D%20%5B%5D%3B%0A%20%20%20%20this.bufferSize%20%3D%20options.bufferSize%20%7C%7C%20100%3B%0A%20%20%20%20this.flushInterval%20%3D%20options.flushInterval%20%7C%7C%205000%3B%0A%20%20%20%20this.writing%20%3D%20false%3B%0A%20%20%20%20%0A%20%20%20%20setInterval(()%20%3D%3E%20this.flush()%2C%20this.flushInterval)%3B%0A%20%20%7D%0A%20%20%0A%20%20log(level%2C%20message%2C%20meta%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20const%20logEntry%20%3D%20%7B%0A%20%20%20%20%20%20timestamp%3A%20new%20Date().toISOString()%2C%0A%20%20%20%20%20%20level%2C%0A%20%20%20%20%20%20message%2C%0A%20%20%20%20%20%20meta%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20this.buffer.push(logEntry)%3B%0A%20%20%20%20%0A%20%20%20%20if%20(this.buffer.length%20%3E%3D%20this.bufferSize)%20%7B%0A%20%20%20%20%20%20setImmediate(()%20%3D%3E%20this.flush())%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20async%20flush()%20%7B%0A%20%20%20%20if%20(this.writing%20%7C%7C%20this.buffer.length%20%3D%3D%3D%200)%20return%3B%0A%20%20%20%20%0A%20%20%20%20this.writing%20%3D%20true%3B%0A%20%20%20%20const%20entries%20%3D%20this.buffer.splice(0)%3B%0A%20%20%20%20%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20await%20this.writeToStorage(entries)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%2F%2F%20Re-add%20entries%20to%20buffer%20on%20failure%0A%20%20%20%20%20%20this.buffer.unshift(...entries)%3B%0A%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20this.writing%20%3D%20false%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20async%20writeToStorage(entries)%20%7B%0A%20%20%20%20%2F%2F%20Write%20to%20file%2C%20database%2C%20or%20external%20service%0A%20%20%20%20const%20logData%20%3D%20entries.map(entry%20%3D%3E%20JSON.stringify(entry)).join('%5Cn')%3B%0A%20%20%20%20await%20fs.promises.appendFile('app.log'%2C%20logData%20%2B%20'%5Cn')%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncLogger {
  constructor(options = {}) {
    this.buffer = [];
    this.bufferSize = options.bufferSize || 100;
    this.flushInterval = options.flushInterval || 5000;
    this.writing = false;
    
    setInterval(() =&gt; this.flush(), this.flushInterval);
  }
  
  log(level, message, meta = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      meta
    };
    
    this.buffer.push(logEntry);
    
    if (this.buffer.length &gt;= this.bufferSize) {
      setImmediate(() =&gt; this.flush());
    }
  }
  
  async flush() {
    if (this.writing || this.buffer.length === 0) return;
    
    this.writing = true;
    const entries = this.buffer.splice(0);
    
    try {
      await this.writeToStorage(entries);
    } catch (error) {
      // Re-add entries to buffer on failure
      this.buffer.unshift(...entries);
    } finally {
      this.writing = false;
    }
  }
  
  async writeToStorage(entries) {
    // Write to file, database, or external service
    const logData = entries.map(entry =&gt; JSON.stringify(entry)).join('\n');
    await fs.promises.appendFile('app.log', logData + '\n');
  }
}
</code></pre>
</div>

<p><strong>236. How do you handle async operations in error scenarios?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20ErrorHandler%20%7B%0A%20%20static%20async%20withRetry(fn%2C%20options%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20const%20%7B%20maxRetries%20%3D%203%2C%20backoff%20%3D%201000%2C%20retryCondition%20%7D%20%3D%20options%3B%0A%20%20%20%20%0A%20%20%20%20for%20(let%20attempt%20%3D%201%3B%20attempt%20%3C%3D%20maxRetries%3B%20attempt%2B%2B)%20%7B%0A%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20return%20await%20fn()%3B%0A%20%20%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%20%20const%20shouldRetry%20%3D%20retryCondition%20%3F%20%0A%20%20%20%20%20%20%20%20%20%20retryCondition(error%2C%20attempt)%20%3A%20%0A%20%20%20%20%20%20%20%20%20%20attempt%20%3C%20maxRetries%3B%0A%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20if%20(!shouldRetry)%20throw%20error%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20await%20new%20Promise(resolve%20%3D%3E%20%0A%20%20%20%20%20%20%20%20%20%20setTimeout(resolve%2C%20backoff%20*%20attempt)%0A%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20static%20async%20withFallback(primaryFn%2C%20fallbackFn)%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20return%20await%20primaryFn()%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.warn('Primary%20operation%20failed%2C%20using%20fallback%3A'%2C%20error.message)%3B%0A%20%20%20%20%20%20return%20await%20fallbackFn()%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20static%20async%20withGracefulDegradation(operations)%20%7B%0A%20%20%20%20const%20results%20%3D%20%5B%5D%3B%0A%20%20%20%20%0A%20%20%20%20for%20(const%20operation%20of%20operations)%20%7B%0A%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20const%20result%20%3D%20await%20operation()%3B%0A%20%20%20%20%20%20%20%20results.push(%7B%20success%3A%20true%2C%20data%3A%20result%20%7D)%3B%0A%20%20%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%20%20results.push(%7B%20success%3A%20false%2C%20error%3A%20error.message%20%7D)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20return%20results%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class ErrorHandler {
  static async withRetry(fn, options = {}) {
    const { maxRetries = 3, backoff = 1000, retryCondition } = options;
    
    for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        const shouldRetry = retryCondition ? 
          retryCondition(error, attempt) : 
          attempt &lt; maxRetries;
          
        if (!shouldRetry) throw error;
        
        await new Promise(resolve =&gt; 
          setTimeout(resolve, backoff * attempt)
        );
      }
    }
  }
  
  static async withFallback(primaryFn, fallbackFn) {
    try {
      return await primaryFn();
    } catch (error) {
      console.warn('Primary operation failed, using fallback:', error.message);
      return await fallbackFn();
    }
  }
  
  static async withGracefulDegradation(operations) {
    const results = [];
    
    for (const operation of operations) {
      try {
        const result = await operation();
        results.push({ success: true, data: result });
      } catch (error) {
        results.push({ success: false, error: error.message });
      }
    }
    
    return results;
  }
}
</code></pre>
</div>

<p><strong>237. How do you implement async caching strategies?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncCache%20%7B%0A%20%20constructor(options%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20this.cache%20%3D%20new%20Map()%3B%0A%20%20%20%20this.ttl%20%3D%20options.ttl%20%7C%7C%20300000%3B%20%2F%2F%205%20minutes%0A%20%20%20%20this.maxSize%20%3D%20options.maxSize%20%7C%7C%201000%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20get(key%2C%20fetchFn)%20%7B%0A%20%20%20%20const%20cached%20%3D%20this.cache.get(key)%3B%0A%20%20%20%20%0A%20%20%20%20if%20(cached%20%26%26%20Date.now()%20%3C%20cached.expires)%20%7B%0A%20%20%20%20%20%20return%20cached.value%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Cache%20miss%20or%20expired%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20value%20%3D%20await%20fetchFn()%3B%0A%20%20%20%20%20%20this.set(key%2C%20value)%3B%0A%20%20%20%20%20%20return%20value%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%2F%2F%20Return%20stale%20data%20if%20available%0A%20%20%20%20%20%20if%20(cached)%20%7B%0A%20%20%20%20%20%20%20%20console.warn('Using%20stale%20cache%20data%20due%20to%20error%3A'%2C%20error.message)%3B%0A%20%20%20%20%20%20%20%20return%20cached.value%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20throw%20error%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20set(key%2C%20value)%20%7B%0A%20%20%20%20%2F%2F%20Implement%20LRU%20eviction%20if%20needed%0A%20%20%20%20if%20(this.cache.size%20%3E%3D%20this.maxSize)%20%7B%0A%20%20%20%20%20%20const%20firstKey%20%3D%20this.cache.keys().next().value%3B%0A%20%20%20%20%20%20this.cache.delete(firstKey)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20this.cache.set(key%2C%20%7B%0A%20%20%20%20%20%20value%2C%0A%20%20%20%20%20%20expires%3A%20Date.now()%20%2B%20this.ttl%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20mget(keys%2C%20fetchFn)%20%7B%0A%20%20%20%20const%20results%20%3D%20%7B%7D%3B%0A%20%20%20%20const%20missingKeys%20%3D%20%5B%5D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Check%20cache%20for%20each%20key%0A%20%20%20%20for%20(const%20key%20of%20keys)%20%7B%0A%20%20%20%20%20%20const%20cached%20%3D%20this.cache.get(key)%3B%0A%20%20%20%20%20%20if%20(cached%20%26%26%20Date.now()%20%3C%20cached.expires)%20%7B%0A%20%20%20%20%20%20%20%20results%5Bkey%5D%20%3D%20cached.value%3B%0A%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20missingKeys.push(key)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Fetch%20missing%20keys%0A%20%20%20%20if%20(missingKeys.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20const%20fetchedData%20%3D%20await%20fetchFn(missingKeys)%3B%0A%20%20%20%20%20%20for%20(const%20%5Bkey%2C%20value%5D%20of%20Object.entries(fetchedData))%20%7B%0A%20%20%20%20%20%20%20%20this.set(key%2C%20value)%3B%0A%20%20%20%20%20%20%20%20results%5Bkey%5D%20%3D%20value%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20return%20results%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncCache {
  constructor(options = {}) {
    this.cache = new Map();
    this.ttl = options.ttl || 300000; // 5 minutes
    this.maxSize = options.maxSize || 1000;
  }
  
  async get(key, fetchFn) {
    const cached = this.cache.get(key);
    
    if (cached && Date.now() &lt; cached.expires) {
      return cached.value;
    }
    
    // Cache miss or expired
    try {
      const value = await fetchFn();
      this.set(key, value);
      return value;
    } catch (error) {
      // Return stale data if available
      if (cached) {
        console.warn('Using stale cache data due to error:', error.message);
        return cached.value;
      }
      throw error;
    }
  }
  
  set(key, value) {
    // Implement LRU eviction if needed
    if (this.cache.size &gt;= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      value,
      expires: Date.now() + this.ttl
    });
  }
  
  async mget(keys, fetchFn) {
    const results = {};
    const missingKeys = [];
    
    // Check cache for each key
    for (const key of keys) {
      const cached = this.cache.get(key);
      if (cached && Date.now() &lt; cached.expires) {
        results[key] = cached.value;
      } else {
        missingKeys.push(key);
      }
    }
    
    // Fetch missing keys
    if (missingKeys.length &gt; 0) {
      const fetchedData = await fetchFn(missingKeys);
      for (const [key, value] of Object.entries(fetchedData)) {
        this.set(key, value);
        results[key] = value;
      }
    }
    
    return results;
  }
}
</code></pre>
</div>

<p><strong>238. How do you handle async operations with backpressure?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20BackpressureHandler%20%7B%0A%20%20constructor(options%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20this.maxConcurrency%20%3D%20options.maxConcurrency%20%7C%7C%2010%3B%0A%20%20%20%20this.maxQueueSize%20%3D%20options.maxQueueSize%20%7C%7C%20100%3B%0A%20%20%20%20this.running%20%3D%200%3B%0A%20%20%20%20this.queue%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20process(asyncFn)%20%7B%0A%20%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20%20%20if%20(this.queue.length%20%3E%3D%20this.maxQueueSize)%20%7B%0A%20%20%20%20%20%20%20%20reject(new%20Error('Queue%20is%20full%20-%20backpressure%20applied'))%3B%0A%20%20%20%20%20%20%20%20return%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20this.queue.push(%7B%20asyncFn%2C%20resolve%2C%20reject%20%7D)%3B%0A%20%20%20%20%20%20this.processNext()%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20processNext()%20%7B%0A%20%20%20%20if%20(this.running%20%3E%3D%20this.maxConcurrency%20%7C%7C%20this.queue.length%20%3D%3D%3D%200)%20%7B%0A%20%20%20%20%20%20return%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20this.running%2B%2B%3B%0A%20%20%20%20const%20%7B%20asyncFn%2C%20resolve%2C%20reject%20%7D%20%3D%20this.queue.shift()%3B%0A%20%20%20%20%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20result%20%3D%20await%20asyncFn()%3B%0A%20%20%20%20%20%20resolve(result)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20reject(error)%3B%0A%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20this.running--%3B%0A%20%20%20%20%20%20setImmediate(()%20%3D%3E%20this.processNext())%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20getStats()%20%7B%0A%20%20%20%20return%20%7B%0A%20%20%20%20%20%20running%3A%20this.running%2C%0A%20%20%20%20%20%20queued%3A%20this.queue.length%2C%0A%20%20%20%20%20%20capacity%3A%20this.maxConcurrency%2C%0A%20%20%20%20%20%20queueCapacity%3A%20this.maxQueueSize%0A%20%20%20%20%7D%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class BackpressureHandler {
  constructor(options = {}) {
    this.maxConcurrency = options.maxConcurrency || 10;
    this.maxQueueSize = options.maxQueueSize || 100;
    this.running = 0;
    this.queue = [];
  }
  
  async process(asyncFn) {
    return new Promise((resolve, reject) =&gt; {
      if (this.queue.length &gt;= this.maxQueueSize) {
        reject(new Error('Queue is full - backpressure applied'));
        return;
      }
      
      this.queue.push({ asyncFn, resolve, reject });
      this.processNext();
    });
  }
  
  async processNext() {
    if (this.running &gt;= this.maxConcurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { asyncFn, resolve, reject } = this.queue.shift();
    
    try {
      const result = await asyncFn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      setImmediate(() =&gt; this.processNext());
    }
  }
  
  getStats() {
    return {
      running: this.running,
      queued: this.queue.length,
      capacity: this.maxConcurrency,
      queueCapacity: this.maxQueueSize
    };
  }
}
</code></pre>
</div>

<p><strong>239. How do you implement async data transformation pipelines?</strong></p>

<p><strong>Example:</strong></p>


<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20AsyncPipeline%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20this.stages%20%3D%20%5B%5D%3B%0A%20%20%7D%0A%20%20%0A%20%20addStage(name%2C%20transformFn%2C%20options%20%3D%20%7B%7D)%20%7B%0A%20%20%20%20this.stages.push(%7B%0A%20%20%20%20%20%20name%2C%0A%20%20%20%20%20%20transformFn%2C%0A%20%20%20%20%20%20concurrency%3A%20options.concurrency%20%7C%7C%201%2C%0A%20%20%20%20%20%20retries%3A%20options.retries%20%7C%7C%200%0A%20%20%20%20%7D)%3B%0A%20%20%20%20return%20this%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20process(data)%20%7B%0A%20%20%20%20let%20currentData%20%3D%20data%3B%0A%20%20%20%20%0A%20%20%20%20for%20(const%20stage%20of%20this.stages)%20%7B%0A%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20currentData%20%3D%20await%20this.processStage(stage%2C%20currentData)%3B%0A%20%20%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%20%20throw%20new%20Error(%60Pipeline%20failed%20at%20stage%20%24%7Bstage.name%7D%3A%20%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20return%20currentData%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20processStage(stage%2C%20data)%20%7B%0A%20%20%20%20const%20%7B%20transformFn%2C%20concurrency%2C%20retries%20%7D%20%3D%20stage%3B%0A%20%20%20%20%0A%20%20%20%20if%20(Array.isArray(data))%20%7B%0A%20%20%20%20%20%20%2F%2F%20Process%20array%20with%20concurrency%20control%0A%20%20%20%20%20%20const%20results%20%3D%20%5B%5D%3B%0A%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20data.length%3B%20i%20%2B%3D%20concurrency)%20%7B%0A%20%20%20%20%20%20%20%20const%20batch%20%3D%20data.slice(i%2C%20i%20%2B%20concurrency)%3B%0A%20%20%20%20%20%20%20%20const%20batchResults%20%3D%20await%20Promise.all(%0A%20%20%20%20%20%20%20%20%20%20batch.map(item%20%3D%3E%20this.processWithRetry(transformFn%2C%20item%2C%20retries))%0A%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%20%20results.push(...batchResults)%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20return%20results%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%2F%2F%20Process%20single%20item%0A%20%20%20%20%20%20return%20await%20this.processWithRetry(transformFn%2C%20data%2C%20retries)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20async%20processWithRetry(fn%2C%20data%2C%20maxRetries)%20%7B%0A%20%20%20%20for%20(let%20attempt%20%3D%200%3B%20attempt%20%3C%3D%20maxRetries%3B%20attempt%2B%2B)%20%7B%0A%20%20%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20return%20await%20fn(data)%3B%0A%20%20%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20%20%20if%20(attempt%20%3D%3D%3D%20maxRetries)%20throw%20error%3B%0A%20%20%20%20%20%20%20%20await%20new%20Promise(resolve%20%3D%3E%20setTimeout(resolve%2C%201000%20*%20attempt))%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0A%2F%2F%20Usage%0Aconst%20pipeline%20%3D%20new%20AsyncPipeline()%0A%20%20.addStage('validate'%2C%20validateData)%0A%20%20.addStage('transform'%2C%20transformData%2C%20%7B%20concurrency%3A%205%20%7D)%0A%20%20.addStage('enrich'%2C%20enrichData%2C%20%7B%20retries%3A%202%20%7D)%0A%20%20.addStage('save'%2C%20saveData)%3B%0A%0Aconst%20result%20%3D%20await%20pipeline.process(inputData)%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class AsyncPipeline {
  constructor() {
    this.stages = [];
  }
  
  addStage(name, transformFn, options = {}) {
    this.stages.push({
      name,
      transformFn,
      concurrency: options.concurrency || 1,
      retries: options.retries || 0
    });
    return this;
  }
  
  async process(data) {
    let currentData = data;
    
    for (const stage of this.stages) {
      try {
        currentData = await this.processStage(stage, currentData);
      } catch (error) {
        throw new Error(`Pipeline failed at stage ${stage.name}: ${error.message}`);
      }
    }
    
    return currentData;
  }
  
  async processStage(stage, data) {
    const { transformFn, concurrency, retries } = stage;
    
    if (Array.isArray(data)) {
      // Process array with concurrency control
      const results = [];
      for (let i = 0; i &lt; data.length; i += concurrency) {
        const batch = data.slice(i, i + concurrency);
        const batchResults = await Promise.all(
          batch.map(item =&gt; this.processWithRetry(transformFn, item, retries))
        );
        results.push(...batchResults);
      }
      return results;
    } else {
      // Process single item
      return await this.processWithRetry(transformFn, data, retries);
    }
  }
  
  async processWithRetry(fn, data, maxRetries) {
    for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
      try {
        return await fn(data);
      } catch (error) {
        if (attempt === maxRetries) throw error;
        await new Promise(resolve =&gt; setTimeout(resolve, 1000 * attempt));
      }
    }
  }
}

// Usage
const pipeline = new AsyncPipeline()
  .addStage('validate', validateData)
  .addStage('transform', transformData, { concurrency: 5 })
  .addStage('enrich', enrichData, { retries: 2 })
  .addStage('save', saveData);

const result = await pipeline.process(inputData);
</code></pre>
</div>

<p><strong>240. How do you optimize async operations for performance?</strong></p>

<p><strong>Key optimization strategies:</strong></p>

<p>1. <strong>Concurrency Control:</strong></p>



<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="%2F%2F%20Limit%20concurrent%20operations%0Aasync%20function%20processWithConcurrency(items%2C%20asyncFn%2C%20concurrency%20%3D%205)%20%7B%0A%20%20const%20results%20%3D%20%5B%5D%3B%0A%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20items.length%3B%20i%20%2B%3D%20concurrency)%20%7B%0A%20%20%20%20const%20batch%20%3D%20items.slice(i%2C%20i%20%2B%20concurrency)%3B%0A%20%20%20%20const%20batchResults%20%3D%20await%20Promise.all(batch.map(asyncFn))%3B%0A%20%20%20%20results.push(...batchResults)%3B%0A%20%20%7D%0A%20%20return%20results%3B%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">// Limit concurrent operations
async function processWithConcurrency(items, asyncFn, concurrency = 5) {
  const results = [];
  for (let i = 0; i &lt; items.length; i += concurrency) {
    const batch = items.slice(i, i + concurrency);
    const batchResults = await Promise.all(batch.map(asyncFn));
    results.push(...batchResults);
  }
  return results;
}
</code></pre>
</div>

<p>2. <strong>Caching and Memoization:</strong></p>



<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="const%20memoize%20%3D%20(fn%2C%20keyFn%20%3D%20JSON.stringify)%20%3D%3E%20%7B%0A%20%20const%20cache%20%3D%20new%20Map()%3B%0A%20%20return%20async%20(...args)%20%3D%3E%20%7B%0A%20%20%20%20const%20key%20%3D%20keyFn(args)%3B%0A%20%20%20%20if%20(cache.has(key))%20return%20cache.get(key)%3B%0A%20%20%20%20%0A%20%20%20%20const%20result%20%3D%20await%20fn(...args)%3B%0A%20%20%20%20cache.set(key%2C%20result)%3B%0A%20%20%20%20return%20result%3B%0A%20%20%7D%3B%0A%7D%3B%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">const memoize = (fn, keyFn = JSON.stringify) =&gt; {
  const cache = new Map();
  return async (...args) =&gt; {
    const key = keyFn(args);
    if (cache.has(key)) return cache.get(key);
    
    const result = await fn(...args);
    cache.set(key, result);
    return result;
  };
};
</code></pre>
</div>

<p>3. <strong>Connection Pooling:</strong></p>



<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20ConnectionPool%20%7B%0A%20%20constructor(createConnection%2C%20maxConnections%20%3D%2010)%20%7B%0A%20%20%20%20this.createConnection%20%3D%20createConnection%3B%0A%20%20%20%20this.maxConnections%20%3D%20maxConnections%3B%0A%20%20%20%20this.available%20%3D%20%5B%5D%3B%0A%20%20%20%20this.inUse%20%3D%20new%20Set()%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20getConnection()%20%7B%0A%20%20%20%20if%20(this.available.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20const%20conn%20%3D%20this.available.pop()%3B%0A%20%20%20%20%20%20this.inUse.add(conn)%3B%0A%20%20%20%20%20%20return%20conn%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20if%20(this.inUse.size%20%3C%20this.maxConnections)%20%7B%0A%20%20%20%20%20%20const%20conn%20%3D%20await%20this.createConnection()%3B%0A%20%20%20%20%20%20this.inUse.add(conn)%3B%0A%20%20%20%20%20%20return%20conn%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Wait%20for%20available%20connection%0A%20%20%20%20return%20new%20Promise(resolve%20%3D%3E%20%7B%0A%20%20%20%20%20%20const%20checkForConnection%20%3D%20()%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20(this.available.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20%20%20%20%20const%20conn%20%3D%20this.available.pop()%3B%0A%20%20%20%20%20%20%20%20%20%20this.inUse.add(conn)%3B%0A%20%20%20%20%20%20%20%20%20%20resolve(conn)%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20setTimeout(checkForConnection%2C%2010)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20checkForConnection()%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class ConnectionPool {
  constructor(createConnection, maxConnections = 10) {
    this.createConnection = createConnection;
    this.maxConnections = maxConnections;
    this.available = [];
    this.inUse = new Set();
  }
  
  async getConnection() {
    if (this.available.length &gt; 0) {
      const conn = this.available.pop();
      this.inUse.add(conn);
      return conn;
    }
    
    if (this.inUse.size &lt; this.maxConnections) {
      const conn = await this.createConnection();
      this.inUse.add(conn);
      return conn;
    }
    
    // Wait for available connection
    return new Promise(resolve =&gt; {
      const checkForConnection = () =&gt; {
        if (this.available.length &gt; 0) {
          const conn = this.available.pop();
          this.inUse.add(conn);
          resolve(conn);
        } else {
          setTimeout(checkForConnection, 10);
        }
      };
      checkForConnection();
    });
  }
}
</code></pre>
</div>

<p>4. <strong>Batching Operations:</strong></p>



<div class="code-container">
    <div class="code-header">
        <span class="code-language">javascript</span>
        <button class="copy-btn" data-code="class%20BatchProcessor%20%7B%0A%20%20constructor(processFn%2C%20batchSize%20%3D%2010%2C%20delay%20%3D%20100)%20%7B%0A%20%20%20%20this.processFn%20%3D%20processFn%3B%0A%20%20%20%20this.batchSize%20%3D%20batchSize%3B%0A%20%20%20%20this.delay%20%3D%20delay%3B%0A%20%20%20%20this.queue%20%3D%20%5B%5D%3B%0A%20%20%20%20this.processing%20%3D%20false%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20add(item)%20%7B%0A%20%20%20%20return%20new%20Promise((resolve%2C%20reject)%20%3D%3E%20%7B%0A%20%20%20%20%20%20this.queue.push(%7B%20item%2C%20resolve%2C%20reject%20%7D)%3B%0A%20%20%20%20%20%20this.scheduleProcess()%3B%0A%20%20%20%20%7D)%3B%0A%20%20%7D%0A%20%20%0A%20%20scheduleProcess()%20%7B%0A%20%20%20%20if%20(this.processing)%20return%3B%0A%20%20%20%20%0A%20%20%20%20setTimeout(()%20%3D%3E%20this.process()%2C%20this.delay)%3B%0A%20%20%7D%0A%20%20%0A%20%20async%20process()%20%7B%0A%20%20%20%20if%20(this.processing%20%7C%7C%20this.queue.length%20%3D%3D%3D%200)%20return%3B%0A%20%20%20%20%0A%20%20%20%20this.processing%20%3D%20true%3B%0A%20%20%20%20const%20batch%20%3D%20this.queue.splice(0%2C%20this.batchSize)%3B%0A%20%20%20%20%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20const%20items%20%3D%20batch.map(b%20%3D%3E%20b.item)%3B%0A%20%20%20%20%20%20const%20results%20%3D%20await%20this.processFn(items)%3B%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20batch.forEach((b%2C%20index)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20b.resolve(results%5Bindex%5D)%3B%0A%20%20%20%20%20%20%7D)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20batch.forEach(b%20%3D%3E%20b.reject(error))%3B%0A%20%20%20%20%7D%20finally%20%7B%0A%20%20%20%20%20%20this.processing%20%3D%20false%3B%0A%20%20%20%20%20%20if%20(this.queue.length%20%3E%200)%20%7B%0A%20%20%20%20%20%20%20%20setImmediate(()%20%3D%3E%20this.process())%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A">Copy</button>
    </div>
    <pre><code class="language-javascript">class BatchProcessor {
  constructor(processFn, batchSize = 10, delay = 100) {
    this.processFn = processFn;
    this.batchSize = batchSize;
    this.delay = delay;
    this.queue = [];
    this.processing = false;
  }
  
  async add(item) {
    return new Promise((resolve, reject) =&gt; {
      this.queue.push({ item, resolve, reject });
      this.scheduleProcess();
    });
  }
  
  scheduleProcess() {
    if (this.processing) return;
    
    setTimeout(() =&gt; this.process(), this.delay);
  }
  
  async process() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    const batch = this.queue.splice(0, this.batchSize);
    
    try {
      const items = batch.map(b =&gt; b.item);
      const results = await this.processFn(items);
      
      batch.forEach((b, index) =&gt; {
        b.resolve(results[index]);
      });
    } catch (error) {
      batch.forEach(b =&gt; b.reject(error));
    } finally {
      this.processing = false;
      if (this.queue.length &gt; 0) {
        setImmediate(() =&gt; this.process());
      }
    }
  }
}
</code></pre>
</div>

            </div>
        </main>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        
        // Initialize TOC
        document.getElementById('toc-list').innerHTML = `<li><a href="#-promises-async-await-25-questions-" class="h2-link">**Promises & Async/Await (25 Questions)**</a></li><li><a href="#-advanced-patterns-25-questions-" class="h2-link">**Advanced Patterns (25 Questions)**</a></li>`;
        
        // Initialize theme from localStorage
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.body.setAttribute('data-theme', savedTheme);
        const themeButton = document.getElementById('theme-toggle');
        themeButton.textContent = savedTheme === 'dark' ? 'â˜€ï¸ Light Mode' : 'ðŸŒ™ Dark Mode';
        
        // Set initial theme stylesheets
        const lightTheme = document.getElementById('light-theme');
        const darkTheme = document.getElementById('dark-theme');
        if (savedTheme === 'dark') {
            lightTheme.disabled = true;
            darkTheme.disabled = false;
        } else {
            lightTheme.disabled = false;
            darkTheme.disabled = true;
        }
        
        // Mobile menu functionality
        function toggleMobileMenu() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobile-overlay');
            const isOpen = sidebar.classList.contains('mobile-open');
            
            if (isOpen) {
                sidebar.classList.remove('mobile-open');
                overlay.classList.remove('active');
            } else {
                sidebar.classList.add('mobile-open');
                overlay.classList.add('active');
            }
        }
        
        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const button = document.getElementById('theme-toggle');
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            body.setAttribute('data-theme', newTheme);
            button.textContent = newTheme === 'dark' ? 'â˜€ï¸ Light Mode' : 'ðŸŒ™ Dark Mode';
            localStorage.setItem('theme', newTheme);
            
            const lightTheme = document.getElementById('light-theme');
            const darkTheme = document.getElementById('dark-theme');
            if (newTheme === 'dark') {
                lightTheme.disabled = true;
                darkTheme.disabled = false;
            } else {
                lightTheme.disabled = false;
                darkTheme.disabled = true;
            }
            
            // Re-highlight code after theme change
            setTimeout(() => {
                if (typeof Prism !== 'undefined') {
                    Prism.highlightAll();
                }
            }, 100);
        }
        
        // Copy code functionality
        function copyCode(text, button) {
            // Modern clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    button.textContent = 'Copied!';
                    button.style.background = '#10b981';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.style.background = 'var(--accent-color)';
                    }, 2000);
                }).catch(() => {
                    fallbackCopyTextToClipboard(text, button);
                });
            } else {
                fallbackCopyTextToClipboard(text, button);
            }
        }
        
        // Fallback copy function for older browsers
        function fallbackCopyTextToClipboard(text, button) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    button.textContent = 'Copied!';
                    button.style.background = '#10b981';
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.style.background = 'var(--accent-color)';
                    }, 2000);
                } else {
                    throw new Error('Copy command failed');
                }
            } catch (err) {
                console.error('Copy failed:', err);
                button.textContent = 'Copy failed';
                button.style.background = '#ef4444';
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.style.background = 'var(--accent-color)';
                }, 2000);
            } finally {
                document.body.removeChild(textArea);
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Mobile menu button
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            if (mobileMenuBtn) {
                mobileMenuBtn.addEventListener('click', toggleMobileMenu);
            }
            
            // Theme toggle button
            const themeToggleBtn = document.getElementById('theme-toggle');
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', toggleTheme);
            }
            
            // Copy buttons
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('copy-btn')) {
                    const encodedCode = e.target.getAttribute('data-code');
                    if (encodedCode) {
                        const code = decodeURIComponent(encodedCode);
                        copyCode(code, e.target);
                    }
                }
            });
            
            // Overlay and TOC link clicks
            const overlay = document.getElementById('mobile-overlay');
            if (overlay) {
                overlay.addEventListener('click', function() {
                    const sidebar = document.getElementById('sidebar');
                    sidebar.classList.remove('mobile-open');
                    overlay.classList.remove('active');
                });
            }
            
            // TOC links
            document.addEventListener('click', function(e) {
                if (e.target.matches('.toc a')) {
                    const sidebar = document.getElementById('sidebar');
                    const overlay = document.getElementById('mobile-overlay');
                    sidebar.classList.remove('mobile-open');
                    overlay.classList.remove('active');
                }
            });
            
            // Highlight code after page load
            setTimeout(() => {
                if (typeof Prism !== 'undefined') {
                    Prism.highlightAll();
                }
            }, 500);
        });

        

    </script>
</body>
</html>